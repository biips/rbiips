% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmcarray-object.r
\name{mcmcarray-object}
\alias{mcmcarray-object}
\alias{mcmcarray.list-object}
\alias{mcmcarray}
\alias{mcmcarray.list}
\alias{mcmcarray}
\alias{is.mcmcarray}
\alias{is.mcmcarray.list}
\alias{biips_summary.mcmcarray}
\alias{biips_summary.mcmcarray.list}
\alias{biips_table.mcmcarray}
\alias{biips_density.mcmcarray}
\alias{biips_hist}
\alias{biips_hist.mcmcarray}
\alias{biips_table.mcmcarray.list}
\alias{biips_density.mcmcarray.list}
\alias{biips_hist.mcmcarray.list}
\alias{summary.mcmcarray}
\alias{summary.mcmcarray.list}
\alias{density.mcmcarray}
\alias{density.mcmcarray.list}
\alias{hist.mcmcarray}
\alias{hist.mcmcarray.list}
\title{Objects for representing MCMC output.}
\usage{
mcmcarray(data = NA, dim = length(data), dimnames = NULL,
  iteration = length(dim), chain = NA, name = "mcmcarray", lower = NULL,
  upper = NULL)

is.mcmcarray(object)

is.mcmcarray.list(object)

\method{biips_summary}{mcmcarray}(object, probs = c(), order = ifelse(mode,
  0, 1), mode = all(object == as.integer(object)), ...)

\method{biips_summary}{mcmcarray.list}(object, ...)

\method{biips_table}{mcmcarray}(x, ...)

\method{biips_density}{mcmcarray}(x, bw = "nrd0", ...)

biips_hist(x, ...)

\method{biips_hist}{mcmcarray}(x, main = NULL, xlab = NULL, ...)

\method{biips_table}{mcmcarray.list}(x, ...)

\method{biips_density}{mcmcarray.list}(x, bw = "nrd0", ...)

\method{biips_hist}{mcmcarray.list}(x, main = NULL, xlab = NULL, ...)

\method{summary}{mcmcarray}(object, ...)

\method{summary}{mcmcarray.list}(object, ...)

\method{density}{mcmcarray}(x, ...)

\method{density}{mcmcarray.list}(x, ...)

\method{hist}{mcmcarray}(x, ...)

\method{hist}{mcmcarray.list}(x, ...)
}
\arguments{
\item{data}{numerical vector}

\item{dim}{vector of integers. dimension of the array}

\item{dimnames}{character vector}

\item{iteration}{integer. index of the dimension corresponding to iterations
of the MCMC.}

\item{chain}{integer. index of the dimension corresponding to chain of
the MCMC.}

\item{name}{string. variable name}

\item{lower}{vector of integers. variable lower bound}

\item{upper}{vector of integers. variable upper bound}

\item{object, x}{a \code{mcmcarray} or \code{mcmcarray.list} object.}

\item{probs}{vector of reals. probability levels in ]0,1[ for quantiles.
(default = \code{c()})}

\item{order}{integer. Moment statistics of order below or equal to
\code{order} are returned. (default = 0 if all the components are discrete
variables and 1 otherwise)}

\item{mode}{logical. Activate computation of the mode, i.e. the most
frequent value among the particles. (default = \code{TRUE} if all the components
are discrete variables and \code{FALSE} otherwise)}

\item{...}{additional arguments to be passed to the default methods. See
\code{\link[stats]{density}}, \code{\link[graphics]{hist}},
\code{\link[base]{table}}}

\item{bw}{either a real with the smoothing bandwidth to be used or a string
giving a rule to choose the bandwidth. See \code{\link[stats]{bw.nrd}}.
(default=\code{'nrd0'})}

\item{main, xlab}{plotting parameters with useful defaults.}
}
\value{
The methods apply identically to \code{mcmcarray} or
  \code{mcmcarray.list} objects and return a named list with the same named
  members as the input object.

The \code{mcmcarray} function returns an object of class \code{mcmcarray}.

The function \code{is.mcmcarray} returns \code{TRUE} if the object is
  of class \code{mcmcarray}.

The function \code{is.mcmcarray.list} returns \code{TRUE} if the
  object is of class \code{mcmcarray.list}.

The method \code{biips_summary} returns univariate marginal
  statistics. The output innermost members are objects of class
  \code{summary.mcmcarray}, \emph{i.e.} lists with members:
  \item{mean}{mean, if \code{order>=1}.}
  \item{var}{variance, if \code{order>=2}.}
  \item{skew}{skewness, if \code{order>=3}.}
  \item{kurt}{kurtosis, if \code{order>=4}.}
  \item{probs}{vector of quantile probabilities.}
  \item{quant}{list of quantile values, if \code{probs} is not empty.}
  \item{mode}{most frequent values for discrete components.}

The method \code{biips_table} returns univariate marginal frequency
  tables or probability mass estimates of discrete variables. The output
  innermost members are objects of class \code{table.mcmcarray}.

The method \code{biips_density} returns univariate marginal kernel
  density estimates. The output innermost members are objects of class
  \code{density.mcmcarray}.

The method \code{summary} is an alias for \code{biips_summary}.

The method \code{density} is an alias for \code{biips_density}.

The method \code{hist} is an alias for \code{biips_hist}.
}
\description{
A \code{mcmcarray} object is returned by the
  \code{\link{biips_pimh_samples}} or \code{\link{biips_pmmh_samples}}
  functions to represent MCMC output of a given variable.

  A \code{mcmcarray.list} object is a named list of \code{mcmcarray} objects
  for different monitored variables.

  The methods apply identically to \code{mcmcarray} or \code{mcmcarray.list}
  objects and return a named list with the same named members as the input
  object.
}
\examples{
modelfile <- system.file('extdata', 'hmm.bug', package = 'rbiips')
stopifnot(nchar(modelfile) > 0)
cat(readLines(modelfile), sep = '\\n')

#' # PIMH algorithm
data <- list(tmax = 10, p = c(.5, .5), logtau_true = log(1), logtau = log(1))
model <- biips_model(modelfile, data, sample_data = TRUE)

n_part <- 50
obj_pimh <- biips_pimh_init(model, c('x', 'c[2:10]'))  # Initialize
out_pimh_burn <- biips_pimh_update(obj_pimh, 100, n_part)  # Burn-in
out_pimh <- biips_pimh_samples(obj_pimh, 100, n_part)  # Samples

#' Manipulate `mcmcarray.list` object
is.mcmcarray.list(out_pimh)
names(out_pimh)
out_pimh
biips_summary(out_pimh)

#' Manipulate `mcmcarray` object
is.mcmcarray(out_pimh$x)
out_pimh$x
summ_pimh_x <- biips_summary(out_pimh$x, order = 2, probs = c(0.025, 0.975))
summ_pimh_x
dens_pimh_x <- biips_density(out_pimh$x)
par(mfrow = c(2, 2))
plot(dens_pimh_x)
par(mfrow = c(2, 2))
biips_hist(out_pimh$x)

is.mcmcarray(out_pimh[['c[2:10]']])
out_pimh[['c[2:10]']]
summ_pimh_c <- biips_summary(out_pimh[['c[2:10]']])
summ_pimh_c
table_pimh_c <- biips_table(out_pimh[['c[2:10]']])
par(mfrow = c(2, 2))
plot(table_pimh_c)

#' # PMMH algorithm
data <- list(tmax = 10, p = c(.5, .5), logtau_true = log(1))
model <- biips_model(modelfile, data)

n_part <- 50
obj_pmmh <- biips_pmmh_init(model, 'logtau', latent_names = c('x', 'c[2:10]'),
                            inits = list(logtau = -2))  # Initialize
out_pmmh_burn <- biips_pmmh_update(obj_pmmh, 100, n_part)  # Burn-in
out_pmmh <- biips_pmmh_samples(obj_pmmh, 100, n_part, thin = 1)  # Samples

#' Manipulate `mcmcarray.list` object
is.mcmcarray.list(out_pmmh)
names(out_pmmh)
out_pmmh
biips_summary(out_pmmh)

#' Manipulate `mcmcarray` object
is.mcmcarray(out_pmmh$logtau)
out_pmmh$logtau
summ_pmmh_lt <- biips_summary(out_pmmh$logtau, order = 2, probs = c(0.025, 0.975))
dens_pmmh_lt <- biips_density(out_pmmh$logtau)
par(mfrow = c(2, 1))
plot(dens_pmmh_lt)
biips_hist(out_pmmh$logtau)

is.mcmcarray(out_pmmh$x)
out_pmmh$x
summ_pmmh_x <- biips_summary(out_pmmh$x, order = 2, probs = c(0.025, 0.975))
dens_pmmh_x <- biips_density(out_pmmh$x)
par(mfrow = c(2, 2))
plot(dens_pmmh_x)
par(mfrow = c(2, 2))
biips_hist(out_pmmh$x)

is.mcmcarray(out_pmmh[['c[2:10]']])
out_pmmh[['c[2:10]']]
summ_pmmh_c <- biips_summary(out_pmmh[['c[2:10]']])
table_pmmh_c <- biips_table(out_pmmh[['c[2:10]']])
par(mfrow = c(2, 2))
plot(table_pmmh_c)
}
\seealso{
\code{\link[stats]{density}}
}
