% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smcarray-object.r
\name{smcarray-object}
\alias{smcarray-object}
\alias{smcarray.fsb-object}
\alias{smcarray.fsb.list-object}
\alias{smcarray}
\alias{smcarray.fsb}
\alias{smcarray.fsb.list}
\alias{is.smcarray}
\alias{is.smcarray.fsb}
\alias{is.smcarray.fsb.list}
\alias{biips_diagnosis}
\alias{biips_diagnosis.smcarray}
\alias{biips_diagnosis.smcarray.fsb}
\alias{biips_diagnosis.smcarray.fsb.list}
\alias{biips_summary}
\alias{biips_summary.smcarray}
\alias{biips_summary.smcarray.fsb}
\alias{biips_summary.smcarray.fsb.list}
\alias{biips_table}
\alias{biips_table.smcarray}
\alias{biips_density}
\alias{biips_density.smcarray}
\alias{biips_table.smcarray.fsb}
\alias{biips_density.smcarray.fsb}
\alias{biips_table.smcarray.fsb.list}
\alias{biips_density.smcarray.fsb.list}
\alias{summary.smcarray}
\alias{summary.smcarray.fsb}
\alias{summary.smcarray.fsb.list}
\alias{density.smcarray}
\alias{density.smcarray.fsb}
\alias{density.smcarray.fsb.list}
\title{Objects for representing SMC output.}
\usage{
is.smcarray(object)

is.smcarray.fsb(object)

is.smcarray.fsb.list(object)

biips_diagnosis(object, ...)

\method{biips_diagnosis}{smcarray}(object, ess_thres = 30, quiet = FALSE,
  ...)

\method{biips_diagnosis}{smcarray.fsb}(object, type = "fsb", quiet = FALSE,
  ...)

\method{biips_diagnosis}{smcarray.fsb.list}(object, type = "fsb",
  quiet = FALSE, ...)

biips_summary(object, ...)

\method{biips_summary}{smcarray}(object, probs = c(), order = ifelse(mode,
  0, 1), mode = all(object$discrete), ...)

\method{biips_summary}{smcarray.fsb}(object, ...)

\method{biips_summary}{smcarray.fsb.list}(object, ...)

biips_table(x, ...)

\method{biips_table}{smcarray}(x, ...)

biips_density(x, ...)

\method{biips_density}{smcarray}(x, bw = "nrd0", ...)

\method{biips_table}{smcarray.fsb}(x, ...)

\method{biips_density}{smcarray.fsb}(x, bw = "nrd0", adjust = 1, ...)

\method{biips_table}{smcarray.fsb.list}(x, ...)

\method{biips_density}{smcarray.fsb.list}(x, bw = "nrd0", ...)

\method{summary}{smcarray}(object, ...)

\method{summary}{smcarray.fsb}(object, ...)

\method{summary}{smcarray.fsb.list}(object, ...)

\method{density}{smcarray}(x, ...)

\method{density}{smcarray.fsb}(x, ...)

\method{density}{smcarray.fsb.list}(x, ...)
}
\arguments{
\item{object, x}{a \code{smcarray}, \code{smcarray.fsb} or
\code{smcarray.fsb.list} object.}

\item{...}{additional arguments to be passed to the default methods. See
\code{\link[stats]{density}}, \code{\link[base]{table}}}

\item{ess_thres}{integer. Threshold on the Effective Sample Size (ESS). If
all the ESS components are over \code{ess_thres}, the diagnostic is
\code{'GOOD'}, otherwise it is \code{'BAD'}. (default=30).}

\item{quiet}{logical. Disable message display. (default=\code{FALSE}).}

\item{type}{string containing the characters \code{'f'} (fitering),
\code{'s'} (smoothing) and/or \code{'b'} (backward smoothing).
Select the corresponding members of the input to be analysed.
(default = \code{'fsb'}).}

\item{probs}{vector of reals. probability levels in ]0,1[ for quantiles.
(default = \code{c()})}

\item{order}{integer. Moment statistics of order below or equal to
\code{order} are returned. (default = 0 if all the components are discrete
variables and 1 otherwise)}

\item{mode}{logical. Activate computation of the mode, i.e. the most
frequent value among the particles. (default = \code{TRUE} if all the components
are discrete variables and \code{FALSE} otherwise)}

\item{bw}{either a real with the smoothing bandwidth to be used or a string
giving a rule to choose the bandwidth. See \code{\link[stats]{bw.nrd}}.
(default=\code{'nrd0'})}

\item{adjust}{scale factor for the bandwidth. the bandwidth used is actually
\code{adjust*bw}. This makes it easy to specify values like \sQuote{half
the default} bandwidth. (default = 1)}
}
\value{
The methods apply identically to \code{smcarray}, \code{smcarray.fsb} or
  \code{smcarray.fsb.list} objects and return a named list with the same
  named members as the input object.

The function \code{is.smcarray} returns \code{TRUE} if the object is of class \code{smcarray}.

The function \code{is.smcarray.fsb} returns \code{TRUE} if the object
  is of class \code{smcarray.fsb}.

The function \code{is.smcarray.fsb.list} returns \code{TRUE} if the
  object is of class \code{smcarray.fsb.list}.

The method \code{biips_diagnosis} prints diagnosis of the SMC output
  and returns the minimum ESS value.

The method \code{biips_summary} returns univariate marginal
  statistics. The output innermost members are objects of class
  \code{summary.smcarray}. Assuming \code{dim} is the dimension of the
  variable, the \code{summary.smcarray} object is a list with the following
  members:
  \item{mean}{array of size \code{dim}. The mean if \code{order>=1}.}
  \item{var}{array of size \code{dim}. The variance, if \code{order>=2}.}
  \item{skew}{array of size \code{dim}. The skewness, if \code{order>=3}.}
  \item{kurt}{array of size \code{dim}. The kurtosis, if \code{order>=4}.}
  \item{probs}{vector of quantile probabilities.}
  \item{quant}{list of arrays of size \code{dim} for each probability level
      in \code{probs}. The quantile values, if \code{probs} is not empty.}
  \item{mode}{array of size \code{dim}. The most frequent values for
      discrete components.}

The method \code{biips_table} returns univariate marginal frequency
  tables or probability mass estimates of discrete variables. The output
  innermost members are objects of class \code{table.smcarray}.

The method \code{biips_density} returns univariate marginal kernel
  density estimates. The output innermost members are objects of class
  \code{density.smcarray}.

The method \code{summary} is an alias for \code{biips_summary}.

The method \code{density} is an alias for \code{biips_density}.
}
\description{
A \code{smcarray} object is used by the
\code{\link{biips_smc_samples}} function to represent SMC output or particles
of a given variable.

A \code{smcarray.fsb} object is a named list of \code{smcarray} objects with
different types of monitoring for the same variable. Members in this list
have names \code{f} (filtering), \code{s} (smoothing) or \code{b} (backward
smoothing).

A \code{smcarray.fsb.list} object is a named list of \code{smcarray.fsb}
objects for different monitored variables. It might also contain a member
named \code{log_marg_like} with an estimate of the log marginal likelihood.

The methods apply identically to \code{smcarray}, \code{smcarray.fsb} or
\code{smcarray.fsb.list} objects and return a named list with the same named
members as the input object.
}
\details{
Assuming \code{dim} is the dimension of the monitored variable, a
  \code{smcarray} object is a list with the members:
  \describe{
    \item{values}{array of dimension \code{c(dim, n_part)} with the values of
      the particles.}
    \item{weights}{array of dimension \code{c(dim, n_part)} with the weights
      of the particles.}
    \item{ess}{array of dimension \code{dim} with Effective Sample Sizes of
      the particles set.}
    \item{discrete}{array of dimension \code{dim} with logicals indicating
      discreteness of each component.}
    \item{iterations}{array of dimension \code{dim} with sampling iterations
      of each component.}
    \item{conditionals}{lists of the contitioning variables (observations). Its
      value is:
      \itemize{
        \item for filtering: a list of dimension \code{dim}. each member is a
          character vector with the respective conditioning variables of
          the node array component.
        \item for smoothing/backward_smoothing: a character vector, the same
          for all the components of the node array.
      }}
    \item{name}{string with the name of the variable.}
    \item{lower}{vector with the lower bounds of the variable.}
    \item{upper}{vector with the upper bounds of the variable.}
    \item{type}{string with the type of monitor (\code{'filtering'},
      \code{'smoothing'} or \code{'backward_smoothing'}).}
  }

  For instance, if \code{out_smc} is a \code{smcarray.fsb.list} object, one can
  access the values of the smoothing particles for the variable \code{'x'}
  with: \code{out_smc$x$s$values}.
}
\examples{
modelfile <- system.file('extdata', 'hmm.bug', package = 'rbiips')
stopifnot(nchar(modelfile) > 0)
cat(readLines(modelfile), sep = '\\n')

data <- list(tmax = 10, p = c(.5, .5), logtau_true = log(1), logtau = log(1))
model <- biips_model(modelfile, data, sample_data = TRUE)

n_part <- 100
out_smc <- biips_smc_samples(model, c('x', 'c[2:10]'), n_part, type = 'fs',
                             rs_thres = 0.5, rs_type = 'stratified')

#' Manipulate `smcarray.fsb.list` object
is.smcarray.fsb.list(out_smc)
names(out_smc)
out_smc
biips_diagnosis(out_smc)
biips_summary(out_smc)

#' Manipulate `smcarray.fsb` object
is.smcarray.fsb(out_smc$x)
names(out_smc$x)
out_smc$x
biips_diagnosis(out_smc$x)
summ_smc_x <- biips_summary(out_smc$x, order = 2, probs = c(.025, .975))
summ_smc_x
dens_smc_x <- biips_density(out_smc$x, bw = 'nrd0', adjust = 1, n = 100)
par(mfrow = c(2, 2))
plot(dens_smc_x)

is.smcarray.fsb(out_smc[['c[2:10]']])
names(out_smc[['c[2:10]']])
out_smc[['c[2:10]']]
biips_diagnosis(out_smc[['c[2:10]']])
summ_smc_c <- biips_summary(out_smc[['c[2:10]']])
summ_smc_c
table_smc_c <- biips_table(out_smc[['c[2:10]']])
par(mfrow = c(2, 2))
plot(table_smc_c)

#' Manipulate `smcarray` object
is.smcarray(out_smc$x$f)
names(out_smc$x$f)
out_smc$x$f
out_smc$x$s
biips_diagnosis(out_smc$x$f)
biips_diagnosis(out_smc$x$s)
biips_summary(out_smc$x$f)
biips_summary(out_smc$x$s)
par(mfrow = c(2, 2))
plot(biips_density(out_smc$x$f))
par(mfrow = c(2, 2))
plot(biips_density(out_smc$x$s))

par(mfrow = c(2, 2))
plot(biips_table(out_smc[['c[2:10]']]$f))
par(mfrow = c(2, 2))
plot(biips_table(out_smc[['c[2:10]']]$s))
}
\seealso{
\code{\link[stats]{density}}
}
