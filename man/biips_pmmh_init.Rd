% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmmh.r
\name{biips_pmmh_init}
\alias{biips_pmmh_init}
\title{Create PMMH objects}
\usage{
biips_pmmh_init(model, param_names, latent_names = c(), inits = list(),
  rw_step = list(), transform = TRUE, n_rescale = 400, alpha = 0.99,
  beta = 0.05)
}
\arguments{
\item{model}{\code{biips} model object as returned by
\code{\link{biips_model}}.}

\item{param_names}{character vector. The names of the variables updated with
MH proposal. The names can contain subset indices which must define a valid
subset of the variables of the model, e.g.: \code{c('var1',} \code{'var2[1]',}
\code{'var3[1:10]',} \code{'var4[1, 5:10, 3]')}.}

\item{latent_names}{character vector. The names of the variables to be
updated with SMC proposal that need to be monitored.}

\item{inits}{list of numeric values. Initial values for the parameters
in \code{param_names}. (default = samples from the prior distribution).
\code{inits} can either be a named list with no unnamed member or an
unnamed list of the same length as \code{param_names}.}

\item{rw_step}{list of numeric values. Random walk standard deviations.
\code{rw_step} can either be a named list with no unnamed member or an
unnamed list of the same length as \code{param_names}. If \code{transform}
is \code{TRUE} (default), the given standard deviations apply to the transformed variables.
Set \code{transform} to \code{FALSE} if you wish to set the random walk standard deviation for the
untransformed random variables.}

\item{transform}{logical. Activate automatic parameters transformation
(default = \code{TRUE}). Transformations apply independently to each
component of the parameters depending on their support: \itemize{ \item
unbounded (-\eqn{\infty}, +\eqn{\infty}): f(x) = x \item lower bounded [L,
+\eqn{\infty}): f(x) = log(x-L) \item upper bounded (-\eqn{\infty}, U]:
f(x) = log(U-x) \item lower-upper bounded [L, U]: f(x) = log((x-L)/(U-x)) }
so that we apply a random walk on the real-valued transformed vector.}

\item{n_rescale}{integer. Number of iterations for rescaling (default =
400).}

\item{alpha}{real in [0,1]. Tuning parameter of the rescaling
(default = 0.99).}

\item{beta}{real in [0,1]. Tuning parameter of the proposal (default
= 0.05).}
}
\value{
The function \code{biips_pmmh_init} returns an object of class
  \code{pmmh} which can be used to generate samples from the posterior
  distribution of the monitored variables in \code{param_names} and
  \code{latent_names}.

  An object of class \code{pmmh} is a list of functions that share a common
  environment. These functions are meant for internal purpose only. They are
  used to query information on the current state of the algorithm.
  \item{model()}{Get the \code{\link{biips}} model object.}
  \item{param_names()}{Get a character vector with the names of the monitored
    parameters.}
  \item{latent_names()}{Get a character vector with the names of
    the monitored latents.}
  \item{sample_param(sample)}{Get and set the current sample value of the parameters.}
  \item{sample_param_tr(sample)}{Get and set the current sample value of the
    transfromed parameters.}
  \item{sample_latent(sample)}{Get and set the current sample value of the
    latents.}
  \item{log_prior(log_prior)}{Get and set the current value of the
    log prior of the parameters.}
  \item{log_marg_like(log_marg_like)}{Get and set the current value of
    the log marginal likelihood.}
  \item{n_iter()}{Get and set the current curent number of iterations.}
  \item{n_rescale()}{Get the nb of iterations for rescaling.}
  \item{rw_dim()}{Get the dimensions of the parameters.}
  \item{rw_len()}{Get the total length of the parameters.}
  \item{rw_step()}{Get the random walk standard deviations for the
    rescaling.}
  \item{rw_cov()}{Get the empirical covariance matrix of the samples.}
  \item{rw_alpha()}{Get the tuning parameter of the rescaling.}
  \item{rw_beta()}{Get the tuning parameter of the proposal.}
  \item{rw_transform(sample, funtype = 'transform')}{Applies transformation
    function defined by the \code{funtype} string argument. Possible values are
    \code{'transform'} (direct transformation), \code{'inverse'} (inverse
    transformation) and \code{'lderiv'} (log derivative of the transformation).}
  \item{rw_rescale(ar)}{rescales the random walk step to target an optimal
    acceptance rate.}
  \item{rw_learn_cov()}{update the empirical covariance matrix of the samples.}
}
\description{
The function \code{biips_pmmh_init} initializes the Particle Marginal
Metropolis-Hastings (PMMH) algorithm.

The PMMH algorithm is a particle MCMC algorithm using SMC within a MCMC
algorithm. It splits the variables in the graphical model into two sets:
\itemize{
  \item The parameters in \code{param_names} are sampled with a MH proposal
  (multivariate Gaussian random walk). They must be continuous and must be defined as
  single stochastic nodes in the model.
  \item The other latent variables are sampled using a SMC algorithm. They can
  be monitored using the \code{latent_names} parameter.
}
}
\examples{
modelfile <- system.file('extdata', 'hmm.bug', package = 'rbiips')
stopifnot(nchar(modelfile) > 0)
cat(readLines(modelfile), sep = '\\n')

data <- list(tmax = 10, p = c(.5, .5), logtau_true = log(1))
model <- biips_model(modelfile, data)

n_part <- 50
obj_pmmh <- biips_pmmh_init(model, 'logtau', latent_names = c('x', 'c[2:10]'),
                            inits = list(logtau = -2))  # Initialize
is.pmmh(obj_pmmh)
out_pmmh_burn <- biips_pmmh_update(obj_pmmh, 100, n_part)  # Burn-in
out_pmmh <- biips_pmmh_samples(obj_pmmh, 100, n_part, thin = 1)  # Samples
}
\seealso{
\code{\link{biips_model}}, \code{\link{biips_pmmh_update}},
  \code{\link{biips_pmmh_samples}}
}
